---
title: "SheafCanon_OF"
author: "Olivia Freides"
date: "4/06/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Modeling Robinson's SheafCanon Sheaf:

For specifics and citations, reference https://arxiv.org/abs/1603.01446

Robinson, Michael. “Sheaves Are the Canonical Data Structure for Sensor Integration.” Information Fusion, vol. 36, Elsevier B.V, 2017, pp. 208–24, https://doi.org/10.1016/j.inffus.2016.12.002.


```{r}
library(tidyverse)
```


```{r Table 1}
Table1 <- read.csv("Assignment2.csv") # Copied Table 1, page 218.
Table1
```

```{r Global Vars?}
#Should these be global variables?
r_1x <- -73.662574
r_1y <- 42.733838
r_2x <- -77.0897
r_2y <- 38.935
```

What should be done with variables outside of the assignment table that we need? Constraints for functions not in any assignment table...

## Restriction Functions:
Page 214: s_x, s_y are coordinates of an object detected in the satellite image, r_1x, r_1y are coordinates of the first RDF sensor and r_2x, r_2y are coordinates of the second RDF sensor. 

$$A(x, y, z, v_x, v_y, t) = \bigg(tan^{-1}\frac{x+v_xt-r_{1x}}{y+v_yt-r_{1y}}, t\bigg)$$

## Functions for DMAP  

```{r Functions A}
A <- function(stalk) {
  r_1x <- -73.662574
  r_1y <- 42.733838

  stalk %>%
    mutate(Theta1=180/pi*atan2(x + v_x*t/(110.567*cos(y*pi/180)) - r_1x, y + v_y*t/110.567 - r_1y)) %>% # degrees
    select(Theta1, t)
  
}
```


$$B(x, y, z, v_x, v_y, t) = \bigg(tan^{-1}\frac{x+v_xt-r_{2x}}{y+v_yt-r_{2y}}, t\bigg)$$

```{r Functions B}
B <- function(stalk) {
  r_2x <- -77.0897
  r_2y <- 38.935
  
    stalk %>%
      mutate(Theta2= 180/pi*atan2(x + v_x*t/(110.567*cos(y*pi/180)) - r_2x, y + v_y*t/110.567 - r_2y)) %>% # degrees
      select(Theta2, t)
}
```


$$C(s_x, s_y) = tan^{-1}\frac{s_x-r_{1x}}{s_y-r_{1y}}$$

```{r Functions C}
C <- function(stalk) {
  r_1x <- -73.662574
  r_1y <- 42.733838

  stalk %>%
    mutate(Theta1=atan2(s_x - r_1x, s_y - r_1y)) %>%
    select(c(Theta1))
}
```


$$D(s_x, s_y) = tan^{-1}\frac{s_x-r_{2x}}{s_y-r_{2y}}$$


```{r Functions D}
D <- function(stalk){
  r_2x <- -77.0897
  r_2y <- 38.935

  stalk %>%
    mutate(Theta2=atan2(s_x - r_2x, s_y - r_2y)) %>%
    select(c(Theta2))
}
```

$$E(x, y, z, v_x, v_y, t) = (x+v_xt, y+v_yt)$$

 s = expected location, where coordinates = y + displacement and x+ displacement from the equation 
 
```{r Functions E}
E <- function(stalk) {
    stalk %>%
      mutate(s_x = c(x + v_x*t/(110.567*cos(y*pi/180))), s_y = c(y + v_y*t/110.567)) %>% # degrees
      select(c(s_x, s_y))
}

```



Check Example 15:

```{r Functions Proj 1}
pr1xpr2 <- function(stalk){ 
  stalk %>%
      select(c(x, y, z, v_x, v_y))
}
```

pr1 for u2 -> u1

```{r Functions Proj 2}
U2_pr1 <- function(stalk){
  stalk %>%
  select(c(x, y, z))
}
```

pr1 for u3 -> v1

```{r Functions Proj 3}
U3_pr1 <- function(stalk){
  stalk %>%
      select(c(Theta1))
}
```

pr2 for u3 -> v3

```{r Functions Proj 4}
U3_pr2 <- function(stalk){
  stalk %>%
      select(c(t))
}
```

pr1 for u4 -> v2

```{r Functions Proj 5}
U4_pr1 <- function(stalk){
  stalk %>%
      select(c(Theta2))
}
```

pr1 for u4 -> v3

```{r Functions Proj 6}
U4_pr2 <- function(stalk){
  stalk %>%
      select(c(t))
}

```

\textbf{ID function return itself, refer to image for components.}

```{r Functions Identity X}
ID_X <- function(stalk){
  stalk %>%
    select(c(x, y, z, v_x, v_y, s_x, s_y, t, Theta1, Theta2))
}
```


```{r Functions Identity U1}
ID_U1 <- function(stalk){
  stalk %>%
    select(c(x, y, z))
}
```


```{r Functions Identity U2}
ID_U2 <- function(stalk){
  stalk %>%
    select(c(x, y, z, v_x, v_y))
}
```


```{r Functions Identity U3}
ID_U3 <- function(stalk){
  stalk %>%
    select(c(Theta1, t))
}
```


```{r Functions Identity U4}
ID_U4 <- function(stalk){
  stalk %>%
    select(c(Theta2, t))
}
```


```{r Functions Identity U5}
ID_U5 <- function(stalk){
  stalk %>%
    select(c(s_x, s_y, Theta1, Theta2))
}
```


```{r Functions Identity V1}
ID_V1 <- function(stalk){
  stalk %>%
      select(c(Theta1))
}
```


```{r Functions Identity V2}
ID_V2 <- function(stalk){
  stalk %>%
      select(c(Theta2))
}
```


```{r Functions V3}
ID_V3 <- function(stalk){
  stalk %>%
      select(c(t))
}
```




## Table representation of Figure 6 (b), page 214:

![Figure 6](sheafcanon6ab.png)


```{r Table 6B}
SixB <- tibble(SSource = c("X", "X", "X", "X", "U2", "U3", "U3", "U5", "U5", "U4", 
                           "U4", "X", "U1", "U2", "U3", "U4", "U5", "V1", "V2", "V3"), 
               SDest =  c("U2", "U3", "U5", "U4", "U1", "V1", "V3", "V1", "V2", "V3",
                          "V2", "X", "U1", "U2", "U3", "U4", "U5", "V1", "V2","V3"),
               DMap = c(pr1xpr2, A, E, B, U2_pr1, U3_pr1, U3_pr2, C, D, U4_pr2,
                        U4_pr1, ID_X, ID_U1, ID_U2, ID_U3, ID_U4, ID_U5, ID_V2, 
                        ID_V2, ID_V3))

#ID maps w functions and SSource+SDest =.
```


Note: exec takes the function in .x and runs with input .y

```{r}
Table1 %>%
  select(entity, Case1, Key)%>%
  pivot_wider(names_from = entity, values_from = Case1)%>%
  right_join(SixB, by = c(Key = "SSource")) %>%
  nest(stalkinput = 2:12) %>%
  mutate(stalkoutput = map2(.x= DMap, .y = stalkinput, .f = exec)) -> FinSheaf 

FinSheaf

Table1 %>%
  select(entity, Case1, Key) -> localsections
```


## Consistency Radius: 

radius=ish sd/var of stalkoutputs/ diameter of stalkoutputs. Coord. comp
Unnest, aggregate along all of the columns. 
Put the STD together, remember units are diff
chi square, norm. var. 
Ideally have user supply aggregation function. 

process below should be a specific function, so to optimize consistency radius. best consistency radius function like lm() taking consistency radius function.

$$d_U(x,y) = \sqrt{\sum_{i \in columns} \frac{A_i}{ncol} | x_i - y_i| ^2}$$
A is the unit conversion.

We converted everything to radians. 

Unit Conversions

```{r}
UnitScale <- tibble(variable = c("x", "y", "z", "v_x", "v_y", "t", "Theta1", "Theta2", "s_x", "s_y"),
                      scale = c(1*110.567*cos(43*pi/180), 1*110.567, 1/1000, 1, 1, 1, pi/180, pi/180, 1*110.567*cos(43*pi/180), 1*110.567)) # Scaling units

SensorScale <- FinSheaf %>% count(SDest) # Scaling Sensors, by n?
```


```{r}
#Consistency Variance
FinSheaf %>%
  group_by(SDest) %>%
  unnest(stalkoutput)%>%
  summarise(across(4:13, ~ var(.,na.rm = TRUE))) %>% # Probs dont want var...
  pivot_longer(cols = 2:11, names_to = "variable", values_to = "stalk") %>%
  filter(!is.na(stalk)) %>%
  left_join(UnitScale, by = c(variable = "variable")) %>%
  mutate(ScaleValue = n()*stalk*scale^2) %>% # conversion factor applied
  ungroup() %>%
  summarise(ConsistVar = sd(ScaleValue)) %>% # should be a single number.
  sqrt()


FinSheaf %>%
  group_by(SDest) %>%
  unnest(stalkoutput)%>%
  summarise(across(4:13, ~ n()*var(.,na.rm = TRUE))) %>%
  pivot_longer(cols = 2:11, names_to = "variable", values_to = "stalk") %>%
  filter(!is.na(stalk)) %>%
  left_join(UnitScale, by = c(variable = "variable")) %>%
  mutate(ScaleValue = stalk*scale^2) %>% # conversion factor applied
  ungroup() %>%
  summarise(ConsistSD = sqrt(sum(ScaleValue)))
```


```{r}
#Consistency Radius
FinSheaf %>%
  group_by(SDest) %>%
  unnest(stalkoutput)%>%
  pivot_longer(cols = 5:14, names_to = "entity", values_to = "stalk")%>%
  left_join(localsections, by = c(entity = "entity", SDest = "Key")) %>%
  mutate(deviations = (stalk-Case1)^2) %>%
  filter(!is.na(deviations))%>%
  left_join(UnitScale, by = c(entity = "variable")) %>%
  mutate(ScaleValue = deviations*scale^2) %>% # conversion factor applied
  ungroup() %>%
  summarise(ConsistRad = sqrt(sum(ScaleValue)))
  
#variances add. SD's dont. 
#
#Unit Conversions:

# have pre-consistency radii , un-group and aggregate all rads to 
# get consistency radius.
# ends with: for each stalk you have a radius, then aggregate them, max, sum of squares. 


```

??? First part of Du{} ???
Dmap applied on assignment? or just stalkouput?



```{r}
# #Need sheaf and assignment as easy to get things within the df.. I need an assignment table.
# consistrad <- function(sheaf, assignment){
#   sheaf %>% select(stalkoutput)
#     
# }
```


# Questions:

Consistency radius vs consistency filtration?

From PNLL+Robinson paper

Joslyn, Cliff A., et al. “A Sheaf Theoretical Approach to Uncertainty Quantification of Heterogeneous Geolocation Information.” Sensors (Basel, Switzerland), vol. 20, no. 12, MDPI, 2020, p. 3418–, https://doi.org/10.3390/s20123418.

The consistency radius (more fully developed by Robinson [2] in later work) provides a native global measure of the uncertainty among the sensors present in any reading. Beyond that, the consistency filtration provides a detailed breakdown of the contributions of particular sensors and sensor combinations to that overall uncertainty.

Pseudometric: function that takes in 2 elements of a set, produces a non negtive real number.
d_u is a pseudometric. 

Maximum aggregation variant:
Note: \mathcal{} marking sheaves and collections of subsets. :)
Supremum vs Max:
- Least of upper bounds
vs
- The biggest one
-1/x x>0, always a negative number. Any positive is an upper bound. Least of upper bounds is zero. SUP = 0, Max = ND.
In practice, MAX.

$$c_{\mathcal{S}}(a) := \sup_{U \subseteq V \in \mathcal{T}} \; d_U((\mathcal{S}(U \subseteq V)) a(V), a(U))$$
^ Sensitive to outliers. Better for theorem proving.
d_U is a fn, the pseud. produces real num. 

Norm: input element of set, produces non neg real num. 

Stalk outputs: $\mathcal{S}(U \subseteq V)) a(V)$

Lest squares aggregation variant:
$$c_{\mathcal{S}}(a) := \sqrt{\sum_{U \subseteq V \in \mathcal{T}} \; d_u((\mathcal{S}(U \subseteq V)) a(V), a(U))^2}$$

^Less sensitive to outliers

Every norm on $\mathbb{R}^n$ has an associated consistency radius. 

Small means min. disagreement among observations, large some sensors disagree.

Per Pysheaf: Computes the error between the data assignments and extended assignments on the sheaf
      :param numpyNormType: Optional, how the errors across the sheaf are combined.
      default is take maximum error.
      :param cellStartIndices: Optional, which cells may start the data flowed into 
      this cell
      :returns: Error between the data assignments and extended assignments on the 
      sheaf

norm(differences in assignment?)




# Relevant Testing:

```{r}
# Keep in mind when pivoting for consistency rad.

Table1 %>%
  mutate(label = str_c(Sensor, ".", entity))%>%
  select(label, Case1, Key)%>%
  pivot_wider(names_from = label, values_from = Case1)


```

Testing variances:

```{r}
FinSheaf %>%
  group_by(SDest) %>%
  unnest(stalkoutput) %>%
  summarise(across(4:13, ~ var(.,na.rm = TRUE))) -> Testsheaf

# have pre-consistency radii , un-group and aggregate all rads to 
# get consistency radius.
# ends with: for each stalk you have a radius, then aggregate them, max, sum of squares. 

mtcars %>%
  summarise(across(.cols = mpg:gear, .fns = ~sd(.)))

# mutate(diff = across(stalkoutput,  ~lead(.x) - (.x)))


```

Testing to Make one cons. rad:
```{r}
#du(S(U5 subset X)(a(x)), a(U5)) = (output of dmap x to u5, ID output)
# take in:
#FinSheaf %>% filter(SDest == "U1")%>% mutate(diff = across(c(x,y,z),  ~lead(.x) - (.x)))
# or reduce(x, "-")) 
# doesnt work but i want it to. 


Testsheaf %>% filter(SDest == "U1")%>% mutate(diff = x[1]-x[2])
# works but uses idnexing :(


#Testsheaf %>% mutate(diff = .[SDest == "U1",] - .[Key == "U2",])
# Doesnt work but i want it to. -> if you can just run through pairs of sdests and jeys

# FinSheaf%>% 
#   filter(SDest == "U1") %>%
#   pivot_wider(stalkoutput, id_cols = c(Key, SDest))
# 
# 
#   mutate(diff = across(stalkoutput,  ~lead(.x) - (.x)))


  
```


